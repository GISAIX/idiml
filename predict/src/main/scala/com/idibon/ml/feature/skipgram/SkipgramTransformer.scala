package com.idibon.ml.feature.skipgram

import com.idibon.ml.alloy.Alloy
import com.idibon.ml.common.Engine
import com.idibon.ml.feature._
import org.json4s._

/** Skip-gram transformation
  *
  * Skim-grams are ProductFeatures generated by skipping up to k grams
  * between each of n grams from a sequence of features (ie grams).
  *
  * @param k the maximum distance between each gram chosen
  * @param n the number of grams in a skip-gram
  */

class SkipgramTransformer(k: Int, n: Int) extends FeatureTransformer with Archivable[SkipgramTransformer, SkipgramTransformerLoader] {

 def apply(input: Seq[Feature[_]]): Seq[ProductFeature] = {

    if (input.length < math.min(n, k)) {
      return Seq[ProductFeature]()
    }
    else {
      val skipPerms = getSkipPermutations(k, n) //get all the permutations of "skips" with k,n
      val len = input.length
      val startGrams = (0 to len - n) //all the possible starting grams for a skip gram
      
      /* loop through all possible starting grams, generating a skipgram for each
       * permutation of 0->k skips */
      startGrams.map(gram => {
        skipPerms.foldLeft(List[ProductFeature]())((perm_accum, perm) => {
          //create this skipgram if the indices are in bounds
          if (perm.last + gram < len) {
            //maps a permutation (list of inidices) into a list of features
            perm_accum :+ new ProductFeature(perm.foldLeft(List[Feature[_]](input(gram)))((accum, to_skip) => {
              accum :+ input(gram + to_skip)
            }))
          }
          else {
            perm_accum
          }
        })
      }).flatten
    }
  }

  /** Generates the sequence of all possible permutations (repeated) of skips
    * between n grams (allowing repetitions).
    *
    * @param k - Maximum number of skips to choose from
    * @param n - Number of grams the skips go between, result will have n-1 skips
    * @return A sequence of skip length permutations, normalized
    * with offsetList() to provide actual indices within a sequence that will be
    * skipped.
    */
  def getSkipPermutations(k: Int, n: Int): Seq[Seq[Int]] = {
    Seq.fill(n - 1)((0 to k).toIndexedSeq)
      .flatten.combinations(n - 1)
      .map(e => e.permutations)
      .flatten.map(e => offsetList(e))
      .toSeq
  }
  /** Transforms a sequence of indices representing how many
    * spots ahead of the previous index to jump, to a
    * sequence of indices representing which index to land
    * on.
    *
    * @param list - the sequences of indices to skip
    * @return - sequences of indices summed
    */
  def offsetList(list: Seq[Int]):Seq[Int] = {
    list.foldLeft(Seq[Int]())((accum, value) => {
      accum ++ Seq[Int](accum.sum + value + 1)
    })
  }

  def save(writer: Alloy.Writer): Option[JObject] = {
    Some(JObject(List(
      JField("min", JInt(this.k)),
      JField("max", JInt(this.n)))))
  }
}

/** Paired loader class for SkipgramTransformer instances. */
class SkipgramTransformerLoader extends ArchiveLoader[SkipgramTransformer] {

  def load(engine: Engine, reader: Alloy.Reader, config: Option[JObject]) = {
    implicit val formats = DefaultFormats

    val skipgramConfig = config.map(_.extract[SkipgramConfig])

    //TODO: what should the defaults for this be?
    // by default, generate all bi-grams with skip=2
    new SkipgramTransformer(skipgramConfig.flatMap(_.k).getOrElse(2),
      skipgramConfig.flatMap(_.n).getOrElse(2))
  }
}

/** JSON configuration data for the Skip-gram transform
  *
  * @param k - Maximum distance between tokens in a sequence used to
  * generate skipgrams (default: 2)
  * @param n - Number of tokens in a skipgram (default: 2)
  */
sealed case class SkipgramConfig(k: Option[Int], n: Option[Int])
