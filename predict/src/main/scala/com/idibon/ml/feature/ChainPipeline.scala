package com.idibon.ml.feature

import com.idibon.ml.alloy.Alloy
import com.idibon.ml.common.{Archivable, ArchiveLoader, Engine}

import org.apache.spark.mllib.linalg.Vector
import com.typesafe.scalalogging.StrictLogging
import org.json4s.JObject

/** Converts a chain of tokens into a chain of features into a chain of Vectors
  *
  * Second-stage feature extraction for sequence classifiers, used to convert
  * the sequence of tokens generated by a
  * {@link com.idibon.ml.feature.SequenceGenerator} into a chain of feature
  * Vectors.
  */
class ChainPipeline(
  graph: FeatureGraph,
  transforms: Map[String, FeatureTransformer],
  pipeline: Seq[PipelineEntry])
    extends Archivable[ChainPipeline, ChainPipelineLoader]
    with Function2[JObject, Chain[tokenizer.Token], Chain[Vector]]
    with Freezable[ChainPipeline]
    with StrictLogging {

  /** Applies the feature transformation to each element in the Chain */
  def apply(doc: JObject, sequence: Chain[tokenizer.Token]): Chain[Vector] = {
    val transformed = graph(scala.collection.mutable.Map[String, Any](
      FeatureGraph.SequenceInput -> sequence,
      FeatureGraph.DocumentInput -> doc))
    // FIXME: support multiple outputs
    transformed(FeatureGraph.OutputStage).asInstanceOf[Seq[Chain[Vector]]].head
  }

  def save(writer: Alloy.Writer): Option[JObject] = {
    FeatureGraph.saveGraph(writer, transforms, pipeline)
  }

  /** Freezes the graph and all transforms in it
    *
    * @return frozen ChainPipeline
    */
  def freeze(): ChainPipeline = {
    val frozen = transforms.map(_ match {
      case (n, x: Freezable[_]) => (n -> x.freeze.asInstanceOf[FeatureTransformer])
      case other => other
    }).toMap

    val frozenGraph = FeatureGraph[Chain[Vector]](
      graph.name, frozen, pipeline,
      Seq(FeatureGraph.DocumentInput, FeatureGraph.SequenceInput))

    new ChainPipeline(frozenGraph, frozen, pipeline)
  }
}

/** Paired loader class for ChainPipeline */
class ChainPipelineLoader
    extends ArchiveLoader[ChainPipeline]
    with FeatureGraphLoader {

  def load(engine: Engine, reader: Option[Alloy.Reader],
    config: Option[JObject]): ChainPipeline = {

    val transforms = loadTransformers(engine, reader, config)
    val dependencies = loadPipelineEntries(config)

    val graph = FeatureGraph[Chain[Vector]](
      FeaturePipeline.DefaultName, transforms, dependencies,
      Seq(FeatureGraph.DocumentInput, FeatureGraph.SequenceInput))

    val pipeline = new ChainPipeline(graph, transforms, dependencies)
    if (reader.isDefined) pipeline.freeze() else pipeline
  }
}
