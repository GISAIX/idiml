package com.idibon.ml.train.furnace

import scala.util.{Try, Success, Failure}
import scala.concurrent.{Await, ExecutionContext, Future, Promise}
import scala.reflect.runtime.universe.{typeOf, Type, TypeTag}

import com.idibon.ml.train.TrainOptions
import com.idibon.ml.predict._

import org.json4s.JObject

trait Furnace2[+T <: PredictResult] {

  /** Name for the generated model */
  val name: String

  /** Trains the model synchronously
    *
    */
  protected def doTrain(options: TrainOptions): PredictModel[T]

  /** Trains the model asynchronously
    *
    * @param options training configuration options
    * @return an asynchronously-trained model
    */
  def train(options: TrainOptions): Future[PredictModel[T]] = {
    implicit val executor = ExecutionContext.global
    val model = Promise[PredictModel[T]]()
    Future {
      model.complete(Try(doTrain(options)))
    }
    model.future
  }
}

object Furnace2 {

  /** Returns an appropriate builder for a Furnace with a given name
    *
    * @tparam T the type of predict result the alloy will generate
    * @param tpe the type of the furnace to configure
    */
  def builder[T <: PredictResult: TypeTag](tpe: String, config: JObject):
      FurnaceBuilder[T] = {
    REGISTRY(typeOf[T])(tpe)(config).asInstanceOf[FurnaceBuilder[T]]
  }

  // registry of all known furnace types, organized by the model result type
  private[this] val REGISTRY: Map[Type, Map[String, (JObject) => Furnace2[_]]] = Map(
    typeOf[Classification] -> Map()
  )
}

/** Trait for Furnaces which delegates some of the training to other furnaces
  */
trait HasFurnaces[T <: PredictResult] {

  /** Furnaces contained within this furnace, and delegates for training */
  val furnaces: Seq[Furnace2[T]]

  /** Trains all of the furnaces within this container in sequence
    *
    * @param options training configuration options
    * @return the models generated by each furnace
    */
  protected def trainFurnaces(options: TrainOptions): Seq[PredictModel[T]] = {
    /* loop through all of the contained furnaces, training each in order.
     * abort if any model training fails, or exceeds the max train time */
    implicit val context = ExecutionContext.global

    furnaces.map(furnace =>
      Await.ready(furnace.train(options), options.maxTrainTime).value match {
        case Some(Success(model)) => model
        case Some(Failure(reason)) => throw reason
        case _ => throw new Error("Invalid")
      })
  }
}
