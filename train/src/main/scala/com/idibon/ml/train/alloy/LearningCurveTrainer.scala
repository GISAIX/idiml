package com.idibon.ml.train.alloy

import com.idibon.ml.alloy.{HasTrainingSummary, BaseAlloy, Alloy}
import com.idibon.ml.common.Engine
import com.idibon.ml.feature.Buildable
import com.idibon.ml.predict.ml.{TrainingSummary}
import com.idibon.ml.predict.ml.metrics._
import com.idibon.ml.predict.{Classification}
import com.typesafe.scalalogging.StrictLogging
import org.json4s.JsonAST.{JObject}
import org.json4s._


/**
  * This creates learning curves, by using the cross validation alloy trainer.
  *
  * For each portion, it kicks off a cross validation trainer which returns an
  * alloy of cross validation metrics for that portion. We then extract those
  * metrics to create some data points. For posterity all the portion cross
  * validation metrics are also included in the alloy.
  *
  * @author "Stefan Krawczyk <stefan@idibon.com>" on 2/16/16.
  */
class LearningCurveTrainer(builder: LearningCurveTrainerBuilder)
  extends AlloyTrainer with KFoldDataSetCreator with MetricHelper with StrictLogging {
  val engine: Engine = builder.engine
  val trainer: AlloyTrainer = builder.trainerBuilder.build(builder.engine)
  val numFolds: Int = builder.numFolds
  val portions: Array[Double] = builder.portions
  val foldSeed: Long = builder.foldSeed


  /**
    * @param name          - a user-friendly name for the Alloy
    * @param docs          - a callback function returning a traversable sequence
    *                      of JSON training documents, such as those generated by export_training_to_idiml.rb
    * @param labelsAndRules a callback function returning a traversable sequence
    *                      of JSON Config. Should only be one line,   generated by export_training_to_idiml.rb.
    * @param config        training configuration parameters. Optional.
    * @return an Alloy with the trained model
    */
  override def trainAlloy(name: String,
                          docs: () => TraversableOnce[JObject],
                          labelsAndRules: JObject,
                          config: Option[JObject]): Alloy[Classification] = {
    implicit val formats = org.json4s.DefaultFormats
    val uuidToLabel = (labelsAndRules \ "uuid_to_label").extract[JObject]
    val labels = uuidToLabelGenerator(uuidToLabel)
    // for each portion
    val portionAlloys = portions.par.map(portion => {
      // delegate to xval trainer
      val cvat = new CrossValidatingAlloyTrainer(engine, trainer, numFolds, portion, foldSeed, true)
      (portion, cvat.trainAlloy(s"$portion", docs, labelsAndRules, config)
        .asInstanceOf[BaseAlloy[Classification] with HasTrainingSummary])
    }).toList.toSeq
    // get portion summaries
    val portionSummaries = getXValPortionSummaries(portionAlloys)
    // so now we have results for each portion -- already averaged, create LC metrics
    val metricTypeToPortions = transformAndFilterToWantedMetrics(portionSummaries)
    val lcMetrics = createLearningCurveMetrics(metricTypeToPortions)
    val lcSummary = new TrainingSummary(s"$name-LC", lcMetrics)
    logger.info(lcSummary.toString)
    new BaseAlloy[Classification](s"$name-LC", labels, Map()) with HasTrainingSummary {
      override def getTrainingSummaries = {
        Some(Seq(lcSummary) ++ portionSummaries.map(_._2))
      }
    }
  }

  /**
    * Gets the training summaries that come from cross validation.
    *
    * @param portionAlloys
    * @return
    */
  def getXValPortionSummaries(portionAlloys: Seq[(Double, BaseAlloy[Classification] with HasTrainingSummary)]):
  Seq[(Double, TrainingSummary)] = {
    portionAlloys.map({ case (portion, alloy) =>
      (portion, alloy.getTrainingSummaries)
    }).collect({ case (portion: Double, Some(summary)) => (portion, summary) })
      .flatMap({ case (portion, summary) => summary.map(ts => (portion, ts)) })
      // this probably isn't needed, but it's a safeguard anyway
      .filter({ case (portion, ts) => ts.identifier.endsWith(CrossValidatingAlloyTrainer.SUFFIX) })
  }

  /**
    * Creates points for plotting learning curve metrics.
    *
    * This creates LearningCurveLabelF1, LearningCurveLabelPrecision, LearningCurveLabelRecall
    * and LearningCurveF1 metrics.
    *
    * @param metrics
    * @return
    */
  def createLearningCurveMetrics(metrics: Map[MetricTypes, Seq[(Double, Metric with Buildable[_, _])]]):
  Seq[Metric with Buildable[_, _]] = {
    metrics.flatMap({case (metricType, portionMetrics) =>
      val newMetric: Seq[Metric with Buildable[_, _]] = metricType match {
        case MetricTypes.LabelF1 => {
          createLabelPointsMetrics(MetricTypes.LearningCurveLabelF1, MetricClass.Alloy, portionMetrics)
        }
        case MetricTypes.LabelPrecision => {
          createLabelPointsMetrics(MetricTypes.LearningCurveLabelPrecision, MetricClass.Alloy, portionMetrics)
        }
        case MetricTypes.LabelRecall => {
          createLabelPointsMetrics(MetricTypes.LearningCurveLabelRecall, MetricClass.Alloy, portionMetrics)
        }
        case MetricTypes.F1 => {
          //sort into each label
          val points = portionMetrics.map({case (portion, metric) =>
            (portion.toFloat, metric match {case m: FloatMetric => m.float})
          })
          Seq(new PointsMetric(MetricTypes.LearningCurveF1, MetricClass.Alloy, points))
        }
        case other => throw new IllegalStateException(s"Error; should not have encountered ${other}.")
      }
      newMetric
    }).toSeq
  }

  /**
    * This creates a label ploints metrics object.
    *
    * This represents points that can be plotted for a label.
    *
    * @param metricType
    * @param metricClass
    * @param portionMetrics
    * @return
    */
  def createLabelPointsMetrics(metricType: MetricTypes,
                               metricClass: MetricClass.Value,
                               portionMetrics: Seq[(Double, Metric with Buildable[_, _])]) = {
    //sort into each label
    val byLabel = portionMetrics.groupBy({case (portion, metric:LabelFloatMetric) => metric.label})
    byLabel.map({case (label, labelPortionMetrics) =>
      val points = labelPortionMetrics.map({case (portion, metric) =>
        (portion.toFloat, metric match {case m: LabelFloatMetric => m.float})
      })
      new LabelPointsMetric(metricType, metricClass, label, points)
    }).toSeq
  }

  /**
    * Helper method to transform a sequence of (portion, training summary) into just a sequence
    * of (portion, metric).
    *
    * i.e. this flattens the training summaries into just metrics by portion.
    *
    * @param portionSummaries
    * @return
    */
  def transformAndFilterToWantedMetrics(portionSummaries: Seq[(Double, TrainingSummary)]):
  Map[MetricTypes, Seq[(Double, Metric with Buildable[_, _])]] = {
    portionSummaries
      // get all metrics out
      .flatMap({ case (portion, ts) =>
        ts.metrics.map(m => (portion, m))
      })
      // make sure they're the ones we want
      .filter({case (portion, metric) => metric.metricClass == MetricClass.Alloy})

      .groupBy({ case (portion, metric) => metric.metricType })
      .filter({ case (metricType, _) =>
        (metricType == MetricTypes.LabelF1) ||
          (metricType == MetricTypes.LabelPrecision) ||
          (metricType == MetricTypes.LabelRecall) ||
          (metricType == MetricTypes.F1) // gratuitous since it's not used externally...
      })
  }
}
