package com.idibon.ml.train.alloy

import com.idibon.ml.common.Engine
import com.idibon.ml.train.alloy.evaluation.AlloyEvaluator
import org.json4s._

import scala.collection.mutable
import scala.concurrent.{Promise, Await, ExecutionContext, Future}

import com.idibon.ml.train.TrainOptions
import com.idibon.ml.predict.{Classification, Span, Label, PredictResult}
import com.idibon.ml.feature.{Builder, Buildable}
import com.idibon.ml.alloy.{Alloy}

import scala.reflect.runtime.universe.{typeOf, Type, TypeTag}
import scala.util.{Try, Failure, Success}


/**
  * Trait that allows you to create different alloys.
  * @tparam T
  */
trait AlloyForge[T <: PredictResult with Buildable[T, Builder[T]]] {
  val name: String
  val labels: Seq[Label]

  /** Forge the alloy; this is the asynchronous wrapper.
    *
    * @param options configuration options
    * @return an asynchronous training Future with the Alloy
    */
  def forge(options: TrainOptions, evaluator: AlloyEvaluator): Future[Alloy[T]] = {
    implicit val executor = ExecutionContext.global
    val alloy = Promise[Alloy[T]]()
    Future {
      alloy.complete(Try(doForge(options, evaluator)))
    }
    alloy.future
  }

  /**
    * Synchronous method that creates the alloy.
    * @param options
    * @param evaluator
    * @return
    */
  def doForge(options: TrainOptions, evaluator: AlloyEvaluator): Alloy[T]

  /**
    * Returns the appropriate evaluator for this alloy.
    *
    * @param engine
    * @param taskType
    * @return
    */
  def getEvaluator(engine: Engine, taskType: String): AlloyEvaluator

}

object AlloyForge {

  val CONFIG_VERSION = "0.1.0"
  /** Let's declare a type to make it easier to reference */
  type ForgeBuilder = (Engine, String, Seq[Label], JObject) => AlloyForge[_]

  // master registry of all furnaces
  private[this] val _registry = mutable.Map[Type, mutable.Map[String, ForgeBuilder]]()

  /** Register a new furnace type
    *
    * @tparam T class of prediction made by the model
    * @param tpe short name used to identify the furnace class
    * @param b builder function
    */
  private[train] def register[T <: PredictResult: TypeTag](tpe: String, b: ForgeBuilder) {
    val r = _registry.getOrElseUpdate(typeOf[T], mutable.Map[String, ForgeBuilder]())
    r += (tpe -> b)
  }

  /** Re-initializes the registry (for testing) */
  private[train] def resetRegistry() {
    _registry.clear()
    register[Classification]("BasicClassificationAlloyForge", BasicClassificationAlloyForge)
    register[Span]("BasicSpanAlloyForge", BasicSpanAlloyForge)
    register[Span]("CrossValidatingSpanAlloyForge", CrossValidatingSpanAlloyForge)
    register[Span]("LearningCurveSpanAlloyForge", LearningCurveSpanAlloyForge)
  }

  resetRegistry()

  /** Constructs a new Furnace
    *
    * @param engine current engine context
    * @param tpe type of furnace to construct
    * @param name name for the new furnace
    * @param config furnace JSON configuration
    */
  def apply[T <: PredictResult with Buildable[T, Builder[T]]: TypeTag](
      engine: Engine, tpe: String,
      name: String, labels: Seq[Label], config: JObject): AlloyForge[T] = {

    _registry(typeOf[T])(tpe)(engine, name, labels, config).asInstanceOf[AlloyForge[T]]
  }
}

/**
  * Trait to make it easy to forge a forge based on top of other forges.
  * @tparam T
  */
trait HasAlloyForges[T <: PredictResult with Buildable[T, Builder[T]]] {

  /** Forges contained within this forge, and delegates for training */
  val forges: Seq[AlloyForge[T]]

  /** Forges all of the alloys within this container in sequence.
    *
    * @param options training configuration options
    * @return the alloys generated by each alloy forge
    */
  protected def forgeForges(options: TrainOptions, evaluator: AlloyEvaluator): Seq[Alloy[T]] = {
    /* loop through all of the contained furnaces, training each in order.
     * abort if any forge training fails, or exceeds the max train time */
    implicit val context = ExecutionContext.global

    forges.map(forge =>
      Await.ready(forge.forge(options, evaluator), options.maxTrainTime).value match {
        case Some(Success(model)) => model
        case Some(Failure(reason)) => throw reason
        case _ => throw new Error("Invalid")
      })
  }
}
